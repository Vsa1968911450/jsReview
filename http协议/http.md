同源：域名 协议 端口号
跨域网络访问 
跨域写操作 一般是允许的 重定向 表单提交
跨域读操作 一般是不被允许的 但是可以通过内嵌资源进行读取访问
跨域资源嵌入 一般是允许的
例如 
1 script嵌入跨域脚本
2 link放入css
3 img图片
问 受不受同源策略影响 
答 是受同源策略限制 但是 由于跨域的资源嵌入这种方式 导致可以访问
4 video媒体元素
5 @font-face 导入新字体
6 iframe嵌入网页

实现跨域
jsonp 只支持get请求 script标签
<!-- window.name + iframe -->
node中间件 cors
nginx反向代理

http 协议问题 每个版本优缺点
1.0 
（1） 只支持tcp短连接 三次握手  只能前面请求完成才能第二个请求不是并行
（2） 无host头域（域名） 
（3） 不允许断点续传 不能只传输对象一部分 要求传输整个对象 
1.1 
 (1) 引入更多缓存策略 1.0 if-modified-since expires 来作为缓存标准 1.1 entity tag if match等可以选择进行控制
 （2） 请求头假如range头域 允许请求某个资源的某个部分（比如下载 可以间断下载 不用重新下载）
 （3） host头处理 可以存在多个虚拟主机 支持host头域
 （4） 长链接支持 以及 流水线处理 一个tcp连接上可以传送多个http请求 
2.0 
（1）http1是文本  http2新的二进制格式 只认0和1
（2）多路复用 连接共享 一个连接可以多个请求 
和1.1区别 1.1 长链接是串行的（前面请求结束才能下一个）若干个请求排队 前面请求要结束后面才能继续 2.0 长链接是并行的 同事在一个连接上并行执行
 （3）header压缩 1.x header中有大量信息  2.0 用encoder来减少header大小 服务端 客户端都缓存一个表来规定数据 避免header重复传输
 （4）服务端推送 
3.0 基于谷歌的QUIC协议 使用UDP实现 减少tcp三次握手 以及tls（安全传输层协议）
（1）解决了前一个stream丢包 后一个stream阻塞的问题 因为http2 还是基于tcp协议
（2）优化了重传策略 重传包和原来的包编号不一样 减少重传计算的消耗
（3）链接迁移 不在用tcp四元组确定一个连接 而是用一个64位随机数来确定这个链接
（4）更适合流量控制




请求头 请求体 请求行

请求行 请求方法 url地址 协议名称
请求头  http报文头  token安全
请求体 参数


不同浏览器是否可以共享cookie
可以共享,根据同源策略cookie是区分端口的,但是对浏览器来说,cookie是区分域,不区分端口的,在一个ip地址下多个端口的cookie是共享的


http请求过程
1 dns域名解析 得到ip  dns域名解析是递归查询 先去找dns缓存 => 根域名服务器=>再到下一级 找到了就返回
2 更具ip找到服务器 建立tcp链接 
3 发起http请求
4 服务器相应http请求 浏览器拿到css js代码
5 浏览器解析代码 
6 渲染页面

浏览器如何对于页面渲染 
解析html形成dom树 解析css文件构成渲染树 边解析边渲染



http请求由四部分组成
1 请求行 包括 请求方法字段 url字段 http版本协议
2 请求头 一系列键值对组成
3 空行
4 请求正文 


响应码 
1xx 信息响应 
2xx 成功响应
3xx 重定向
4xx 客户端错误  接口方法错 找不到页面等
5xx 服务器端错误 


http协议特点
1 无连接 没刺链接就处理一个请求  后期可以实现长链接
2 独立灵活 客户端服务器知道怎么处理数据
3 无状态 
4 支持服务器 客户端模式
5 简单快速




tcp三次握手 建立连接通道 
客户端发起请求 传递 syn =1 说明新链接 内容 seq = x 
服务器返回收到信息
三次正好 保证数据可靠传输 又可以提高效率
例子 你在吗 我在 哦 相当于对话
客户端收到请求
四次挥手 客户端=》 服务器  服务器反馈给客户端 客户端收到反馈 也给一个反馈给服务器  然后服务器给数据给客户端 客户端拿到数据
服务器需要先回馈 然后准备数据来返回给客户端信息



强缓存  cache-control 优先于expires（http1）  如果服务器文件更新 本地还是有缓存的 拿不到最新的信息 1 html页面不做强缓存  html都是正常的http 2 服务器更新资源让名称和之前不一样（加时间戳）
协商缓存 不管有没有缓存 还是会发起请求 304 通知用户读取缓存  200 返回最新的信息缓存到本地  Last-Modified/ETag
区别：协商缓存总会和服务器协商 一定要发请求 
第一次向服务器请求 
强缓存没有 
协商缓存没有
向服务器发送请求（没有传递任何标识）
服务器收到请求会准备标识 
Last-Modified  资源文件最后更新时间  
ETag  记录的是一个标识（也是根据资源文件更新生成的，每一次资源更新都会重新生成一个ETag）
客户端拿到信息后渲染 把信息 标识缓存到本地


第二次发起请求 带标识
If-Modified-since 对应  Last-Modified
if-None_Match  对应 ETag
304 通知用户读取缓存（localstorage） 如果本地文件丢失会再想服务器发起请求  200 返回最新的信息缓存到本地

域名到服务器  dns解析 也是有缓存的 如果之前解析过会在本地有缓存  少用域名资源 资源都放到同一服务器上  项目中往往会把不同资源放到不同服务器上（）
先看浏览器 再看本地host 再看dns解析器缓存 再看本地dns服务器

